/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunksadaf"] = self["webpackChunksadaf"] || []).push([["node_modules_leaflet-plugins_layer_tile_Bing_addon_applyMaxNativeZoom_js"],{

/***/ "./node_modules/leaflet-plugins/layer/tile/Bing.addon.applyMaxNativeZoom.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/leaflet-plugins/layer/tile/Bing.addon.applyMaxNativeZoom.js ***!
  \**********************************************************************************/
/***/ (() => {

eval("/*\n * Metadata response has `zoomMin`/`zoomMax` properties, that currently (in most cases) are constant: `1`/`21`.\n * But in fact, imagery for 'Aerial*' and (deprecated) 'Road' sets may be absent at high zoom levels,\n * depending on location.\n * This addon is intended to find and apply *real* maximum available zoom (for current location) on layer add.\n * Ref: https://stackoverflow.com/questions/12788245/bing-maps-determine-max-zoom-level-for-static-aerial-map-with-rest-imagery-api\n *\n * @option applyMaxNativeZoom: Boolean|String = 'auto'\n * Determines whether `applyMaxNativeZoom` method will be called on layer add.\n * 'auto' means that option will be active for 'Aerial*' and 'Road' imagery sets\n * (but only if `maxNativeZoom` is not explicitely provided in options).\n *\n * @option applyMaxNativeZoom_validityRadius: Number = 10000000\n * Limits validity of 'measured' max zoom to specified radius.\n * Metadata requests are asynchronous, so when result is ready actual map position can be already changed.\n * if distance between old and new locations is longer than defined by this option,\n * then maxNativeZoom will be recalculated for new position.\n *\n * @method applyMaxNativeZoom(latlng: LatLng): this\n * Try to find maximum available zoom (for current location), and apply it as `maxNativeZoom`.\n * There is no official way, so use heuristic: check `vintageStart` in metadata response.\n * Currently method makes sense for 'Aerial*' and 'Road' imagery sets only.\n *\n * @event maxNativeZoomApplied: Event\n * Fired when applyMaxNativeZoom method succeed.\n * Extends event object with these properties: value, oldValue, latlng.\n */\n\nL.BingLayer.mergeOptions({\n        applyMaxNativeZoom: 'auto',\n        applyMaxNativeZoom_validityRadius: 10000000\n});\n\nL.BingLayer.addInitHook(function () {\n\tvar options = this.options;\n\tif (options.applyMaxNativeZoom === 'auto' && !options.maxNativeZoom) {\n\t\toptions.applyMaxNativeZoom = options.imagerySet === 'Road' ||\n\t\t\toptions.imagerySet.substring(0,6) === 'Aerial';\n\t}\n\tif (options.applyMaxNativeZoom) {\n\t\tthis.on('add',function () {\n\t\t\tthis.applyMaxNativeZoom(this._map.getCenter());\n\t\t});\n\t}\n});\n\nL.BingLayer.include({\n\tapplyMaxNativeZoom: function (latlng) {\n\t\tvar options = this.options;\n\t\t// https://docs.microsoft.com/en-us/bingmaps/rest-services/imagery/get-imagery-metadata#basic-metadata-url\n\t\tvar request = this._makeApiUrl('Imagery/BasicMetadata', L.Util.template('{imagerySet}/{centerPoint}', {\n\t\t\timagerySet: options.imagerySet,\n\t\t\tcenterPoint: L.Util.template('{lat},{lng}', latlng)\n\t\t}));\n\t\tvar zoomOffset = options.zoomOffset || 0;  // detectRetina sideeffects on maxZoom / maxNativeZoom\n\t\tthis._findVintage(request, options.maxZoom + zoomOffset, function (zoom) {\n\t\t\tif (!zoom || !this._map) { return; }\n\t\t\tvar newLatlng = this._map.getCenter();\n\t\t\tvar validityRadius = this.options.applyMaxNativeZoom_validityRadius;\n\t\t\tif (newLatlng.distanceTo(latlng) > validityRadius) {\n\t\t\t\tthis.applyMaxNativeZoom(newLatlng); return;\n\t\t\t}\n\t\t\tzoom -= zoomOffset;\n\t\t\tvar oldValue = options.maxNativeZoom || options.maxZoom;\n\t\t\toptions.maxNativeZoom = zoom;\n\t\t\tvar mapZoom = this._map.getZoom();\n\t\t\tif (zoom<oldValue && zoom<mapZoom || zoom>oldValue && mapZoom>oldValue) {\n\t\t\t\tthis._resetView();\n\t\t\t}\n\t\t\tthis.fire('maxNativeZoomApplied',{\n\t\t\t\tlatlng: latlng,\n\t\t\t\tvalue: zoom,\n\t\t\t\toldValue: oldValue\n\t\t\t});\n\t\t});\n\t\treturn this;\n\t},\n\n\t_findVintage: function (request, zoomLevel, callback, context) {\n\t\t// there is no official way, so use heuristic: check `vintageStart` in metadata response\n\t\tthis.callRestService(request + '&zoomLevel='+zoomLevel, function (meta) {\n\t\t\tif (meta.resourceSets[0].resources[0].vintageStart || zoomLevel === 0) {\n\t\t\t\treturn callback.call(context || this, zoomLevel);\n\t\t\t}\n\t\t\tthis._findVintage(request, zoomLevel-1, callback, context);\n\t\t});\n\t}\n});\n\n\n//# sourceURL=webpack://sadaf/./node_modules/leaflet-plugins/layer/tile/Bing.addon.applyMaxNativeZoom.js?");

/***/ })

}]);