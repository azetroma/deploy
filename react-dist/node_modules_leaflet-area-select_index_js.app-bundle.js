/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunksadaf"] = self["webpackChunksadaf"] || []).push([["node_modules_leaflet-area-select_index_js"],{

/***/ "./node_modules/leaflet-area-select/index.js":
/*!***************************************************!*\
  !*** ./node_modules/leaflet-area-select/index.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./src/Map.SelectArea */ \"./node_modules/leaflet-area-select/src/Map.SelectArea.js\");\n\n\n\n//# sourceURL=webpack://sadaf/./node_modules/leaflet-area-select/index.js?");

/***/ }),

/***/ "./node_modules/leaflet-area-select/src/Map.SelectArea.js":
/*!****************************************************************!*\
  !*** ./node_modules/leaflet-area-select/src/Map.SelectArea.js ***!
  \****************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * L.Map.SelectArea - Area selection tool for leaflet\n *\n * @author Alexander Milevski <info@w8r.name>\n * @see https://github.com/w8r/leaflet-area-select\n * @license MIT\n * @preserve\n */\n\n// UMD\n(function (factory) {\n  var L;\n  if (true) {\n    // AMD\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! leaflet */ \"./node_modules/leaflet/dist/leaflet-src.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n})(function (L) {\n\n  var trueFn = function () { return true; };\n\n  /**\n   * @class  L.Map.SelectArea\n   * @extends {L.Map.BoxZoom}\n   */\n  L.Map.SelectArea = L.Map.BoxZoom.extend({\n\n    statics: {\n\n      /**\n       * @static\n       * @type {String}\n       */\n      AREA_SELECTED: 'areaselected',\n\n      /**\n       * @static\n       * @type {String}\n       */\n      AREA_SELECT_START: 'areaselectstart',\n\n      /**\n       * @static\n       * @type {String}\n       */\n      AREA_SELECTION_TOGGLED: 'areaselecttoggled'\n\n    },\n\n    options: {\n      shiftKey: false,\n      ctrlKey: true,\n      validate: trueFn,\n      autoDisable: false,\n      cursor: 'crosshair'\n    },\n\n    /**\n     * @param  {L.Map} map\n     * @constructor\n     */\n    initialize: function (map, options) {\n      L.Util.setOptions(this, options || {});\n      L.Map.BoxZoom.prototype.initialize.call(this, map);\n\n      /**\n       * @type {Function}\n       */\n      this._validate = null;\n\n      /**\n       * @type {Boolean}\n       */\n      this._moved = false;\n\n      /**\n       * @type {Boolean}\n       */\n      this._autoDisable = !this.options.ctrlKey && this.options.autoDisable;\n\n      /**\n       * @type {L.Point}\n       */\n      this._lastLayerPoint = null;\n\n      /**\n       * @type {String|Null}\n       */\n      this._beforeCursor = null;\n\n      this.setValidate(this.options.validate);\n      this.setAutoDisable(this.options.autoDisable);\n    },\n\n    /**\n     * @param  {Function=} validate\n     * @return {SelectArea}\n     */\n    setValidate: function (validate) {\n      var handler = this;\n      if (typeof validate !== 'function') {\n        validate = trueFn;\n      }\n      this._validate = function (layerPoint) {\n        return validate.call(handler, layerPoint);\n      };\n      return this;\n    },\n\n    /**\n     * @param {Boolean} autoDisable\n     */\n    setAutoDisable: function (autoDisable) {\n      this._autoDisable = !!autoDisable;\n    },\n\n    /**\n     * @param {Boolean} on\n     */\n    setControlKey: function (on) {\n      var wasEnabled = this._enabled;\n      if (wasEnabled) this.disable();\n      this.options.ctrlKey = !!on;\n      if (on) this.options.shiftKey = false;\n      if (wasEnabled) this.enable();\n    },\n\n    /**\n     * @param {Boolean} on\n     */\n    setShiftKey: function (on) {\n      var wasEnabled = this._enabled;\n      if (wasEnabled) this.disable();\n      this.options.shiftKey = !!on;\n      if (on) this.options.ctrlKey = false;\n      if (wasEnabled) this.enable();\n    },\n\n    /**\n     * Disable dragging or zoombox\n     * @param {Function=} validate\n     * @param {Boolean=}  autoDisable\n     */\n    enable: function (validate, autoDisable) {\n      if (this.options.shiftKey) {\n        if (this._map.boxZoom) {\n          this._map.boxZoom.disable();\n        }\n      } else if (!this.options.ctrlKey) {\n        this._map.dragging.disable();\n      }\n      L.Map.BoxZoom.prototype.enable.call(this);\n\n      if (!this.options.ctrlKey) this._setCursor();\n\n      if (validate) this.setValidate(validate);\n      this.setAutoDisable(autoDisable);\n\n      this._map.fire(L.Map.SelectArea.AREA_SELECTION_TOGGLED);\n    },\n\n    /**\n     * Re-enable box zoom or dragging\n     */\n    disable: function () {\n      L.Map.BoxZoom.prototype.disable.call(this);\n\n      if (!this.options.ctrlKey) this._restoreCursor();\n\n      if (this.options.shiftKey) {\n        if (this._map.boxZoom) {\n          this._map.boxZoom.enable();\n        }\n      } else {\n        this._map.dragging.enable();\n      }\n\n      this._map.fire(L.Map.SelectArea.AREA_SELECTION_TOGGLED);\n    },\n\n    /**\n     * Also listen to ESC to cancel interaction\n     * @override\n     */\n    addHooks: function () {\n      L.Map.BoxZoom.prototype.addHooks.call(this);\n      L.DomEvent\n        .on(document, 'keyup', this._onKeyUp, this)\n        .on(document, 'keydown', this._onKeyPress, this)\n        .on(document, 'contextmenu', this._onMouseDown, this)\n        .on(window, 'blur', this._onBlur, this);\n      this._map\n        .on('dragstart', this._onMouseDown, this);\n    },\n\n    /**\n     * @override\n     */\n    removeHooks: function () {\n      L.Map.BoxZoom.prototype.removeHooks.call(this);\n      L.DomEvent\n        .off(document, 'keyup', this._onKeyUp, this)\n        .off(document, 'keydown', this._onKeyPress, this)\n        .off(document, 'contextmenu', this._onMouseDown, this)\n        .off(window, 'blur', this._onBlur, this);\n      this._map.off('dragstart', this._onMouseDown, this);\n    },\n\n    /**\n     * @override\n     */\n    _onMouseDown: function (e) {\n      this._moved = false;\n      this._lastLayerPoint = null;\n\n      if ((this.options.shiftKey && !e.shiftKey) ||\n        (this.options.ctrlKey && !e.ctrlKey) ||\n        ((e.which !== 1) && (e.button !== 1))) {\n        return false;\n      }\n\n      L.DomEvent.stop(e);\n\n      var layerPoint = this._map.mouseEventToLayerPoint(e);\n      if (!this._validate(layerPoint)) return false;\n\n      L.DomUtil.disableTextSelection();\n      L.DomUtil.disableImageDrag();\n\n      this._startLayerPoint = layerPoint;\n\n      L.DomEvent\n        .on(document, 'mousemove', this._onMouseMove, this)\n        .on(document, 'mouseup', this._onMouseUp, this)\n        .on(document, 'keydown', this._onKeyDown, this);\n    },\n\n    /**\n     * @override\n     */\n    _onMouseMove: function (e) {\n      if (!this._moved) {\n        this._box = L.DomUtil.create('div', 'leaflet-zoom-box', this._pane);\n        L.DomUtil.setPosition(this._box, this._startLayerPoint);\n        this._map.fire(L.Map.SelectArea.AREA_SELECT_START);\n      }\n\n      var startPoint = this._startLayerPoint;\n      var box = this._box;\n\n      var layerPoint = this._map.mouseEventToLayerPoint(e);\n      var offset = layerPoint.subtract(startPoint);\n\n      if (!this._validate(layerPoint)) return;\n      this._lastLayerPoint = layerPoint;\n\n      var newPos = new L.Point(\n        Math.min(layerPoint.x, startPoint.x),\n        Math.min(layerPoint.y, startPoint.y)\n      );\n\n      L.DomUtil.setPosition(box, newPos);\n\n      this._moved = true;\n\n      // TODO refactor: remove hardcoded 4 pixels\n      box.style.width = (Math.max(0, Math.abs(offset.x) - 4)) + 'px';\n      box.style.height = (Math.max(0, Math.abs(offset.y) - 4)) + 'px';\n    },\n\n    /**\n     * General on/off toggle\n     * @param  {KeyboardEvent} e\n     */\n    _onKeyUp: function (e) {\n      if (e.keyCode === 27) {\n        if (this._moved && this._box) {\n          this._finish();\n        }\n        // this.disable();\n      } else if (this.options.ctrlKey) {\n        this._restoreCursor();\n        this._map.dragging.enable();\n      }\n    },\n\n    /**\n     * Key down listener to enable on ctrl-press\n     * @param  {KeyboardEvent} e\n     */\n    _onKeyPress: function (e) {\n      if (this.options.ctrlKey && (e.ctrlKey || e.type === 'dragstart')\n        && this._beforeCursor === null) {\n\n        this._setCursor();\n        this._map.dragging._draggable._onUp(e); // hardcore\n        this._map.dragging.disable();\n      }\n    },\n\n    /**\n     * Window blur listener to restore state\n     * @param  {Event} e\n     */\n    _onBlur: function (e) {\n      this._restoreCursor();\n      this._map.dragging.enable();\n    },\n\n\n    /**\n     * Set crosshair cursor\n     */\n    _setCursor: function () {\n      this._beforeCursor = this._container.style.cursor;\n      this._container.style.cursor = this.options.cursor;\n    },\n\n    /**\n     * Restore status quo cursor\n     */\n    _restoreCursor: function () {\n      this._container.style.cursor = this._beforeCursor;\n      this._beforeCursor = null;\n    },\n\n    /**\n     * @override\n     */\n    _onMouseUp: function (e) {\n\n      this._finish();\n\n      var map = this._map;\n      var layerPoint = this._lastLayerPoint; // map.mouseEventToLayerPoint(e);\n\n      if (!layerPoint || this._startLayerPoint.equals(layerPoint)) return;\n      L.DomEvent.stop(e);\n\n      var bounds = new L.LatLngBounds(\n        map.layerPointToLatLng(this._startLayerPoint),\n        map.layerPointToLatLng(layerPoint));\n\n      //map.fitBounds(bounds);\n\n      if (this._autoDisable) {\n        this.disable();\n      } else {\n        this._restoreCursor();\n      }\n\n      this._moved = false;\n\n      L.Util.requestAnimFrame(function () {\n        map.fire(L.Map.SelectArea.AREA_SELECTED, {\n          bounds: bounds\n        });\n      });\n    }\n\n  });\n\n  // expose setting\n  L.Map.mergeOptions({\n    'selectArea': false\n  });\n\n  // register hook\n  L.Map.addInitHook('addHandler', 'selectArea', L.Map.SelectArea);\n\n});\n\n\n//# sourceURL=webpack://sadaf/./node_modules/leaflet-area-select/src/Map.SelectArea.js?");

/***/ })

}]);