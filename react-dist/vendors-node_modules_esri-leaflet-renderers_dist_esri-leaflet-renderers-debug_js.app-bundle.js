/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunksadaf"] = self["webpackChunksadaf"] || []).push([["vendors-node_modules_esri-leaflet-renderers_dist_esri-leaflet-renderers-debug_js"],{

/***/ "./node_modules/esri-leaflet-cluster/src/ClusterFeatureLayer.js":
/*!**********************************************************************!*\
  !*** ./node_modules/esri-leaflet-cluster/src/ClusterFeatureLayer.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FeatureLayer: () => (/* binding */ FeatureLayer),\n/* harmony export */   VERSION: () => (/* binding */ version),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   featureLayer: () => (/* binding */ featureLayer)\n/* harmony export */ });\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! leaflet */ \"./node_modules/leaflet/dist/leaflet-src.js\");\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(leaflet__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var esri_leaflet__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! esri-leaflet */ \"./node_modules/esri-leaflet/src/EsriLeaflet.js\");\n/* harmony import */ var _package_json__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../package.json */ \"./node_modules/esri-leaflet-cluster/package.json\");\n\r\n\r\n\r\nvar version = _package_json__WEBPACK_IMPORTED_MODULE_2__.version;\r\n\r\n\r\nvar FeatureLayer = esri_leaflet__WEBPACK_IMPORTED_MODULE_1__.FeatureManager.extend({\r\n\r\n  statics: {\r\n    EVENTS: 'click dblclick mouseover mouseout mousemove contextmenu popupopen popupclose',\r\n    CLUSTEREVENTS: 'clusterclick clusterdblclick clustermouseover clustermouseout clustermousemove clustercontextmenu'\r\n  },\r\n\r\n  /**\r\n   * Constructor\r\n   */\r\n\r\n  initialize: function (options) {\r\n    esri_leaflet__WEBPACK_IMPORTED_MODULE_1__.FeatureManager.prototype.initialize.call(this, options);\r\n\r\n    options = (0,leaflet__WEBPACK_IMPORTED_MODULE_0__.setOptions)(this, options);\r\n\r\n    this._layers = {};\r\n    this._leafletIds = {};\r\n\r\n    this.cluster = (0,leaflet__WEBPACK_IMPORTED_MODULE_0__.markerClusterGroup)(options);\r\n    this._key = 'c' + (Math.random() * 1e9).toString(36).replace('.', '_');\r\n\r\n    this.cluster.addEventParent(this);\r\n  },\r\n\r\n  /**\r\n   * Layer Interface\r\n   */\r\n\r\n  onAdd: function (map) {\r\n    esri_leaflet__WEBPACK_IMPORTED_MODULE_1__.FeatureManager.prototype.onAdd.call(this, map);\r\n    this._map.addLayer(this.cluster);\r\n  },\r\n\r\n  onRemove: function (map) {\r\n    esri_leaflet__WEBPACK_IMPORTED_MODULE_1__.FeatureManager.prototype.onRemove.call(this, map);\r\n    this._map.removeLayer(this.cluster);\r\n  },\r\n\r\n  /**\r\n   * Feature Management Methods\r\n   */\r\n\r\n  createNewLayer: function (geojson) {\r\n    var layer = leaflet__WEBPACK_IMPORTED_MODULE_0__.GeoJSON.geometryToLayer(geojson, this.options);\r\n    // trap for GeoJSON without geometry\r\n    if (layer) {\r\n      layer.defaultOptions = layer.options;\r\n    }\r\n    return layer;\r\n  },\r\n\r\n  createLayers: function (features) {\r\n    var markers = [];\r\n\r\n    for (var i = features.length - 1; i >= 0; i--) {\r\n      var geojson = features[i];\r\n      var layer = this._layers[geojson.id];\r\n\r\n      if (!layer) {\r\n        layer = this.createNewLayer(geojson);\r\n        layer.feature = leaflet__WEBPACK_IMPORTED_MODULE_0__.GeoJSON.asFeature(geojson);\r\n        layer.defaultOptions = layer.options;\r\n        layer._leaflet_id = this._key + '_' + geojson.id;\r\n\r\n        this.resetStyle(layer.feature.id);\r\n\r\n        // cache the layer\r\n        this._layers[layer.feature.id] = layer;\r\n\r\n        this._leafletIds[layer._leaflet_id] = geojson.id;\r\n\r\n        if (this.options.onEachFeature) {\r\n          this.options.onEachFeature(layer.feature, layer);\r\n        }\r\n\r\n        this.fire('createfeature', {\r\n          feature: layer.feature\r\n        });\r\n      }\r\n\r\n      // add the layer if it is within the time bounds or our layer is not time enabled\r\n      if (!this.options.timeField || (this.options.timeField && this._featureWithinTimeRange(geojson))) {\r\n        markers.push(layer);\r\n      }\r\n    }\r\n\r\n    if (markers.length) {\r\n      this.cluster.addLayers(markers);\r\n    }\r\n  },\r\n\r\n  addLayers: function (ids) {\r\n    var layersToAdd = [];\r\n    for (var i = ids.length - 1; i >= 0; i--) {\r\n      var layer = this._layers[ids[i]];\r\n      this.fire('addfeature', {\r\n        feature: layer.feature\r\n      });\r\n      layersToAdd.push(layer);\r\n    }\r\n    this.cluster.addLayers(layersToAdd);\r\n  },\r\n\r\n  removeLayers: function (ids, permanent) {\r\n    var layersToRemove = [];\r\n    for (var i = ids.length - 1; i >= 0; i--) {\r\n      var id = ids[i];\r\n      var layer = this._layers[id];\r\n      this.fire('removefeature', {\r\n        feature: layer.feature,\r\n        permanent: permanent\r\n      });\r\n      layersToRemove.push(layer);\r\n      if (this._layers[id] && permanent) {\r\n        delete this._layers[id];\r\n      }\r\n    }\r\n    this.cluster.removeLayers(layersToRemove);\r\n  },\r\n\r\n  /**\r\n   * Styling Methods\r\n   */\r\n\r\n  resetStyle: function (id) {\r\n    var layer = this._layers[id];\r\n\r\n    if (layer) {\r\n      layer.options = layer.defaultOptions;\r\n      this.setFeatureStyle(layer.feature.id, this.options.style);\r\n    }\r\n\r\n    return this;\r\n  },\r\n\r\n  setStyle: function (style) {\r\n    this.eachFeature(function (layer) {\r\n      this.setFeatureStyle(layer.feature.id, style);\r\n    }, this);\r\n    return this;\r\n  },\r\n\r\n  setFeatureStyle: function (id, style) {\r\n    var layer = this._layers[id];\r\n\r\n    if (typeof style === 'function') {\r\n      style = style(layer.feature);\r\n    }\r\n    if (layer.setStyle) {\r\n      layer.setStyle(style);\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Utility Methods\r\n   */\r\n\r\n  eachFeature: function (fn, context) {\r\n    for (var i in this._layers) {\r\n      fn.call(context, this._layers[i]);\r\n    }\r\n    return this;\r\n  },\r\n\r\n  getFeature: function (id) {\r\n    return this._layers[id];\r\n  },\r\n\r\n  // This is the same as the Layer.openPopup method except it excludes the `FeatureGroup`\r\n  // logic to work around https://github.com/Leaflet/Leaflet/issues/8761\r\n  openPopup (latlng) {\r\n    if (this._popup) {\r\n      if (this._popup._prepareOpen(latlng || this._latlng)) {\r\n        // open the popup on the map\r\n        this._popup.openOn(this._map);\r\n      }\r\n    }\r\n    return this;\r\n  },\r\n\r\n  // This is the same as the `Layer.openTooltip` method except it excludes the `FeatureGroup`\r\n  // logic to work around https://github.com/Leaflet/Leaflet/issues/8761\r\n  openTooltip (latlng) {\r\n    if (this._tooltip) {\r\n      if (this._tooltip._prepareOpen(latlng)) {\r\n        // open the tooltip on the map\r\n        this._tooltip.openOn(this._map);\r\n\r\n        if (this.getElement) {\r\n          this._setAriaDescribedByOnLayer(this);\r\n        } else if (this.eachLayer) {\r\n          this.eachLayer(this._setAriaDescribedByOnLayer, this);\r\n        }\r\n      }\r\n    }\r\n    return this;\r\n  }\r\n});\r\n\r\nfunction featureLayer (options) {\r\n  return new FeatureLayer(options);\r\n}\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (featureLayer);\r\n\n\n//# sourceURL=webpack://sadaf/./node_modules/esri-leaflet-cluster/src/ClusterFeatureLayer.js?");

/***/ }),

/***/ "./node_modules/esri-leaflet-renderers/dist/esri-leaflet-renderers-debug.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/esri-leaflet-renderers/dist/esri-leaflet-renderers-debug.js ***!
  \**********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("/* esri-leaflet-renderers - v3.0.1 - Mon Aug 28 2023 12:30:52 GMT-0500 (Central Daylight Time)\n * Copyright (c) 2023 Environmental Systems Research Institute, Inc.\n * Apache-2.0 */\n(function (global, factory) {\n   true ? factory(exports, __webpack_require__(/*! leaflet */ \"./node_modules/leaflet/dist/leaflet-src.js\"), __webpack_require__(/*! esri-leaflet */ \"./node_modules/esri-leaflet/src/EsriLeaflet.js\"), __webpack_require__(/*! esri-leaflet-cluster */ \"./node_modules/esri-leaflet-cluster/src/ClusterFeatureLayer.js\")) :\n  0;\n})(this, (function (exports, L, EsriLeaflet, EsriLeafletCluster) { 'use strict';\n\n  function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\n  function _interopNamespace(e) {\n    if (e && e.__esModule) return e;\n    var n = Object.create(null);\n    if (e) {\n      Object.keys(e).forEach(function (k) {\n        if (k !== 'default') {\n          var d = Object.getOwnPropertyDescriptor(e, k);\n          Object.defineProperty(n, k, d.get ? d : {\n            enumerable: true,\n            get: function () { return e[k]; }\n          });\n        }\n      });\n    }\n    n[\"default\"] = e;\n    return Object.freeze(n);\n  }\n\n  var L__default = /*#__PURE__*/_interopDefaultLegacy(L);\n  var EsriLeaflet__namespace = /*#__PURE__*/_interopNamespace(EsriLeaflet);\n  var EsriLeafletCluster__default = /*#__PURE__*/_interopDefaultLegacy(EsriLeafletCluster);\n\n  var Symbol = L.Class.extend({\r\n    initialize: function (symbolJson, options) {\r\n      this._symbolJson = symbolJson;\r\n      this.val = null;\r\n      this._styles = {};\r\n      this._isDefault = false;\r\n      this._layerTransparency = 1;\r\n      if (options && options.layerTransparency) {\r\n        this._layerTransparency = 1 - (options.layerTransparency / 100.0);\r\n      }\r\n    },\r\n\r\n    // the geojson values returned are in points\r\n    pixelValue: function (pointValue) {\r\n      return pointValue * 1.333;\r\n    },\r\n\r\n    // color is an array [r,g,b,a]\r\n    colorValue: function (color) {\r\n      return 'rgb(' + color[0] + ',' + color[1] + ',' + color[2] + ')';\r\n    },\r\n\r\n    alphaValue: function (color) {\r\n      var alpha = color[3] / 255.0;\r\n      return alpha * this._layerTransparency;\r\n    },\r\n\r\n    getSize: function (feature, sizeInfo) {\r\n      var attr = feature.properties;\r\n      var field = sizeInfo.field;\r\n      var size = 0;\r\n      var featureValue = null;\r\n\r\n      if (field) {\r\n        featureValue = attr[field];\r\n        var minSize = sizeInfo.minSize;\r\n        var maxSize = sizeInfo.maxSize;\r\n        var minDataValue = sizeInfo.minDataValue;\r\n        var maxDataValue = sizeInfo.maxDataValue;\r\n        var featureRatio;\r\n        var normField = sizeInfo.normalizationField;\r\n        var normValue = attr ? parseFloat(attr[normField]) : undefined;\r\n\r\n        if (featureValue === null || (normField && ((isNaN(normValue) || normValue === 0)))) {\r\n          return null;\r\n        }\r\n\r\n        if (!isNaN(normValue)) {\r\n          featureValue /= normValue;\r\n        }\r\n\r\n        if (minSize !== null && maxSize !== null && minDataValue !== null && maxDataValue !== null) {\r\n          if (featureValue <= minDataValue) {\r\n            size = minSize;\r\n          } else if (featureValue >= maxDataValue) {\r\n            size = maxSize;\r\n          } else {\r\n            featureRatio = (featureValue - minDataValue) / (maxDataValue - minDataValue);\r\n            size = minSize + (featureRatio * (maxSize - minSize));\r\n          }\r\n        }\r\n        size = isNaN(size) ? 0 : size;\r\n      }\r\n      return size;\r\n    },\r\n\r\n    getColor: function (feature, colorInfo) {\r\n      // required information to get color\r\n      if (!(feature.properties && colorInfo && colorInfo.field && colorInfo.stops)) {\r\n        return null;\r\n      }\r\n\r\n      var attr = feature.properties;\r\n      var featureValue = attr[colorInfo.field];\r\n      var lowerBoundColor, upperBoundColor, lowerBound, upperBound;\r\n      var normField = colorInfo.normalizationField;\r\n      var normValue = attr ? parseFloat(attr[normField]) : undefined;\r\n      if (featureValue === null || (normField && ((isNaN(normValue) || normValue === 0)))) {\r\n        return null;\r\n      }\r\n\r\n      if (!isNaN(normValue)) {\r\n        featureValue /= normValue;\r\n      }\r\n\r\n      if (featureValue <= colorInfo.stops[0].value) {\r\n        return colorInfo.stops[0].color;\r\n      }\r\n      var lastStop = colorInfo.stops[colorInfo.stops.length - 1];\r\n      if (featureValue >= lastStop.value) {\r\n        return lastStop.color;\r\n      }\r\n\r\n      // go through the stops to find min and max\r\n      for (var i = 0; i < colorInfo.stops.length; i++) {\r\n        var stopInfo = colorInfo.stops[i];\r\n\r\n        if (stopInfo.value <= featureValue) {\r\n          lowerBoundColor = stopInfo.color;\r\n          lowerBound = stopInfo.value;\r\n        } else if (stopInfo.value > featureValue) {\r\n          upperBoundColor = stopInfo.color;\r\n          upperBound = stopInfo.value;\r\n          break;\r\n        }\r\n      }\r\n\r\n      // feature falls between two stops, interplate the colors\r\n      if (!isNaN(lowerBound) && !isNaN(upperBound)) {\r\n        var range = upperBound - lowerBound;\r\n        if (range > 0) {\r\n          // more weight the further it is from the lower bound\r\n          var upperBoundColorWeight = (featureValue - lowerBound) / range;\r\n          if (upperBoundColorWeight) {\r\n            // more weight the further it is from the upper bound\r\n            var lowerBoundColorWeight = (upperBound - featureValue) / range;\r\n            if (lowerBoundColorWeight) {\r\n              // interpolate the lower and upper bound color by applying the\r\n              // weights to each of the rgba colors and adding them together\r\n              var interpolatedColor = [];\r\n              for (var j = 0; j < 4; j++) {\r\n                interpolatedColor[j] = Math.round((lowerBoundColor[j] * lowerBoundColorWeight) + (upperBoundColor[j] * upperBoundColorWeight));\r\n              }\r\n              return interpolatedColor;\r\n            } else {\r\n              // no difference between featureValue and upperBound, 100% of upperBoundColor\r\n              return upperBoundColor;\r\n            }\r\n          } else {\r\n            // no difference between featureValue and lowerBound, 100% of lowerBoundColor\r\n            return lowerBoundColor;\r\n          }\r\n        }\r\n      }\r\n      // if we get to here, none of the cases apply so return null\r\n      return null;\r\n    }\r\n  });\n\n  var ShapeMarker = L__default[\"default\"].Path.extend({\n\n    initialize: function (latlng, size, options) {\n      L__default[\"default\"].setOptions(this, options);\n      this._size = size;\n      this._latlng = L__default[\"default\"].latLng(latlng);\n      this._svgCanvasIncludes();\n    },\n\n    toGeoJSON: function () {\n      return L__default[\"default\"].GeoJSON.getFeature(this, {\n        type: 'Point',\n        coordinates: L__default[\"default\"].GeoJSON.latLngToCoords(this.getLatLng())\n      });\n    },\n\n    _svgCanvasIncludes: function () {\n      // implement in sub class\n    },\n\n    _project: function () {\n      this._point = this._map.latLngToLayerPoint(this._latlng);\n    },\n\n    _update: function () {\n      if (this._map) {\n        this._updatePath();\n      }\n    },\n\n    _updatePath: function () {\n      // implement in sub class\n    },\n\n    setLatLng: function (latlng) {\n      this._latlng = L__default[\"default\"].latLng(latlng);\n      this.redraw();\n      return this.fire('move', {latlng: this._latlng});\n    },\n\n    getLatLng: function () {\n      return this._latlng;\n    },\n\n    setSize: function (size) {\n      this._size = size;\n      return this.redraw();\n    },\n\n    getSize: function () {\n      return this._size;\n    }\n  });\n\n  var CrossMarker = ShapeMarker.extend({\n\n    initialize: function (latlng, size, options) {\n      ShapeMarker.prototype.initialize.call(this, latlng, size, options);\n    },\n\n    _updatePath: function () {\n      this._renderer._updateCrossMarker(this);\n    },\n\n    _svgCanvasIncludes: function () {\n      L__default[\"default\"].Canvas.include({\n        _updateCrossMarker: function (layer) {\n          var latlng = layer._point;\n          var offset = layer._size / 2.0;\n          var ctx = this._ctx;\n\n          ctx.beginPath();\n          ctx.moveTo(latlng.x, latlng.y + offset);\n          ctx.lineTo(latlng.x, latlng.y - offset);\n          this._fillStroke(ctx, layer);\n\n          ctx.moveTo(latlng.x - offset, latlng.y);\n          ctx.lineTo(latlng.x + offset, latlng.y);\n          this._fillStroke(ctx, layer);\n        }\n      });\n\n      L__default[\"default\"].SVG.include({\n        _updateCrossMarker: function (layer) {\n          var latlng = layer._point;\n          var offset = layer._size / 2.0;\n\n          if (L__default[\"default\"].Browser.vml) {\n            latlng._round();\n            offset = Math.round(offset);\n          }\n\n          var str = 'M' + latlng.x + ',' + (latlng.y + offset) +\n            'L' + latlng.x + ',' + (latlng.y - offset) +\n            'M' + (latlng.x - offset) + ',' + latlng.y +\n            'L' + (latlng.x + offset) + ',' + latlng.y;\n\n          this._setPath(layer, str);\n        }\n      });\n    }\n  });\n\n  var crossMarker = function (latlng, size, options) {\n    return new CrossMarker(latlng, size, options);\n  };\n\n  var XMarker = ShapeMarker.extend({\n\n    initialize: function (latlng, size, options) {\n      ShapeMarker.prototype.initialize.call(this, latlng, size, options);\n    },\n\n    _updatePath: function () {\n      this._renderer._updateXMarker(this);\n    },\n\n    _svgCanvasIncludes: function () {\n      L__default[\"default\"].Canvas.include({\n        _updateXMarker: function (layer) {\n          var latlng = layer._point;\n          var offset = layer._size / 2.0;\n          var ctx = this._ctx;\n\n          ctx.beginPath();\n\n          ctx.moveTo(latlng.x + offset, latlng.y + offset);\n          ctx.lineTo(latlng.x - offset, latlng.y - offset);\n          this._fillStroke(ctx, layer);\n        }\n      });\n\n      L__default[\"default\"].SVG.include({\n        _updateXMarker: function (layer) {\n          var latlng = layer._point;\n          var offset = layer._size / 2.0;\n\n          if (L__default[\"default\"].Browser.vml) {\n            latlng._round();\n            offset = Math.round(offset);\n          }\n\n          var str = 'M' + (latlng.x + offset) + ',' + (latlng.y + offset) +\n            'L' + (latlng.x - offset) + ',' + (latlng.y - offset) +\n            'M' + (latlng.x - offset) + ',' + (latlng.y + offset) +\n            'L' + (latlng.x + offset) + ',' + (latlng.y - offset);\n\n          this._setPath(layer, str);\n        }\n      });\n    }\n  });\n\n  var xMarker = function (latlng, size, options) {\n    return new XMarker(latlng, size, options);\n  };\n\n  var SquareMarker = ShapeMarker.extend({\n    options: {\n      fill: true\n    },\n\n    initialize: function (latlng, size, options) {\n      ShapeMarker.prototype.initialize.call(this, latlng, size, options);\n    },\n\n    _updatePath: function () {\n      this._renderer._updateSquareMarker(this);\n    },\n\n    _svgCanvasIncludes: function () {\n      L__default[\"default\"].Canvas.include({\n        _updateSquareMarker: function (layer) {\n          var latlng = layer._point;\n          var offset = layer._size / 2.0;\n          var ctx = this._ctx;\n\n          ctx.beginPath();\n\n          ctx.moveTo(latlng.x + offset, latlng.y + offset);\n          ctx.lineTo(latlng.x - offset, latlng.y + offset);\n          ctx.lineTo(latlng.x - offset, latlng.y - offset);\n          ctx.lineTo(latlng.x + offset, latlng.y - offset);\n\n          ctx.closePath();\n\n          this._fillStroke(ctx, layer);\n        }\n      });\n\n      L__default[\"default\"].SVG.include({\n        _updateSquareMarker: function (layer) {\n          var latlng = layer._point;\n          var offset = layer._size / 2.0;\n\n          if (L__default[\"default\"].Browser.vml) {\n            latlng._round();\n            offset = Math.round(offset);\n          }\n\n          var str = 'M' + (latlng.x + offset) + ',' + (latlng.y + offset) +\n            'L' + (latlng.x - offset) + ',' + (latlng.y + offset) +\n            'L' + (latlng.x - offset) + ',' + (latlng.y - offset) +\n            'L' + (latlng.x + offset) + ',' + (latlng.y - offset);\n\n          str = str + (L__default[\"default\"].Browser.svg ? 'z' : 'x');\n\n          this._setPath(layer, str);\n        }\n      });\n    }\n  });\n\n  var squareMarker = function (latlng, size, options) {\n    return new SquareMarker(latlng, size, options);\n  };\n\n  var DiamondMarker = ShapeMarker.extend({\n    options: {\n      fill: true\n    },\n\n    initialize: function (latlng, size, options) {\n      ShapeMarker.prototype.initialize.call(this, latlng, size, options);\n    },\n\n    _updatePath: function () {\n      this._renderer._updateDiamondMarker(this);\n    },\n\n    _svgCanvasIncludes: function () {\n      L__default[\"default\"].Canvas.include({\n        _updateDiamondMarker: function (layer) {\n          var latlng = layer._point;\n          var offset = layer._size / 2.0;\n          var ctx = this._ctx;\n\n          ctx.beginPath();\n\n          ctx.moveTo(latlng.x, latlng.y + offset);\n          ctx.lineTo(latlng.x - offset, latlng.y);\n          ctx.lineTo(latlng.x, latlng.y - offset);\n          ctx.lineTo(latlng.x + offset, latlng.y);\n\n          ctx.closePath();\n\n          this._fillStroke(ctx, layer);\n        }\n      });\n\n      L__default[\"default\"].SVG.include({\n        _updateDiamondMarker: function (layer) {\n          var latlng = layer._point;\n          var offset = layer._size / 2.0;\n\n          if (L__default[\"default\"].Browser.vml) {\n            latlng._round();\n            offset = Math.round(offset);\n          }\n\n          var str = 'M' + latlng.x + ',' + (latlng.y + offset) +\n            'L' + (latlng.x - offset) + ',' + latlng.y +\n            'L' + latlng.x + ',' + (latlng.y - offset) +\n            'L' + (latlng.x + offset) + ',' + latlng.y;\n\n          str = str + (L__default[\"default\"].Browser.svg ? 'z' : 'x');\n\n          this._setPath(layer, str);\n        }\n      });\n    }\n  });\n\n  var diamondMarker = function (latlng, size, options) {\n    return new DiamondMarker(latlng, size, options);\n  };\n\n  var PointSymbol = Symbol.extend({\r\n\r\n    statics: {\r\n      MARKERTYPES: ['esriSMSCircle', 'esriSMSCross', 'esriSMSDiamond', 'esriSMSSquare', 'esriSMSX', 'esriPMS']\r\n    },\r\n\r\n    initialize: function (symbolJson, options) {\r\n      var url;\r\n      Symbol.prototype.initialize.call(this, symbolJson, options);\r\n      if (options) {\r\n        this.serviceUrl = options.url;\r\n      }\r\n      if (symbolJson) {\r\n        if (symbolJson.type === 'esriPMS') {\r\n          var imageUrl = this._symbolJson.url;\r\n          if ((imageUrl && imageUrl.substr(0, 7) === 'http://') || (imageUrl.substr(0, 8) === 'https://')) {\r\n            // web image\r\n            url = this.sanitize(imageUrl);\r\n            this._iconUrl = url;\r\n          } else {\r\n            url = this.serviceUrl + 'images/' + imageUrl;\r\n            this._iconUrl = options && options.token ? url + '?token=' + options.token : url;\r\n          }\r\n          if (symbolJson.imageData) {\r\n            this._iconUrl = 'data:' + symbolJson.contentType + ';base64,' + symbolJson.imageData;\r\n          }\r\n          // leaflet does not allow resizing icons so keep a hash of different\r\n          // icon sizes to try and keep down on the number of icons created\r\n          this._icons = {};\r\n          // create base icon\r\n          this.icon = this._createIcon(this._symbolJson);\r\n        } else {\r\n          this._fillStyles();\r\n        }\r\n      }\r\n    },\r\n\r\n    // prevent html injection in strings\r\n    sanitize: function (str) {\r\n      if (!str) {\r\n        return '';\r\n      }\r\n      var text;\r\n      try {\r\n        // removes html but leaves url link text\r\n        text = str.replace(/<br>/gi, '\\n');\r\n        text = text.replace(/<p.*>/gi, '\\n');\r\n        text = text.replace(/<a.*href='(.*?)'.*>(.*?)<\\/a>/gi, ' $2 ($1) ');\r\n        text = text.replace(/<(?:.|\\s)*?>/g, '');\r\n      } catch (ex) {\r\n        text = null;\r\n      }\r\n      return text;\r\n    },\r\n\r\n    _fillStyles: function () {\r\n      if (this._symbolJson.outline && this._symbolJson.size > 0 && this._symbolJson.outline.style !== 'esriSLSNull') {\r\n        this._styles.stroke = true;\r\n        this._styles.weight = this.pixelValue(this._symbolJson.outline.width);\r\n        this._styles.color = this.colorValue(this._symbolJson.outline.color);\r\n        this._styles.opacity = this.alphaValue(this._symbolJson.outline.color);\r\n      } else {\r\n        this._styles.stroke = false;\r\n      }\r\n      if (this._symbolJson.color) {\r\n        this._styles.fillColor = this.colorValue(this._symbolJson.color);\r\n        this._styles.fillOpacity = this.alphaValue(this._symbolJson.color);\r\n      } else {\r\n        this._styles.fillOpacity = 0;\r\n      }\r\n\r\n      if (this._symbolJson.style === 'esriSMSCircle') {\r\n        this._styles.radius = this.pixelValue(this._symbolJson.size) / 2.0;\r\n      }\r\n    },\r\n\r\n    _createIcon: function (options) {\r\n      var width = this.pixelValue(options.width);\r\n      var height = width;\r\n      if (options.height) {\r\n        height = this.pixelValue(options.height);\r\n      }\r\n      var xOffset = width / 2.0;\r\n      var yOffset = height / 2.0;\r\n\r\n      if (options.xoffset) {\r\n        xOffset += this.pixelValue(options.xoffset);\r\n      }\r\n      if (options.yoffset) {\r\n        yOffset += this.pixelValue(options.yoffset);\r\n      }\r\n\r\n      var icon = L.icon({\r\n        iconUrl: this._iconUrl,\r\n        iconSize: [width, height],\r\n        iconAnchor: [xOffset, yOffset]\r\n      });\r\n      this._icons[options.width.toString()] = icon;\r\n      return icon;\r\n    },\r\n\r\n    _getIcon: function (size) {\r\n      // check to see if it is already created by size\r\n      var icon = this._icons[size.toString()];\r\n      if (!icon) {\r\n        icon = this._createIcon({ width: size });\r\n      }\r\n      return icon;\r\n    },\r\n\r\n    pointToLayer: function (geojson, latlng, visualVariables, options) {\r\n      var size = this._symbolJson.size || this._symbolJson.width;\r\n      if (!this._isDefault) {\r\n        if (visualVariables.sizeInfo) {\r\n          var calculatedSize = this.getSize(geojson, visualVariables.sizeInfo);\r\n          if (calculatedSize) {\r\n            size = calculatedSize;\r\n          }\r\n        }\r\n        if (visualVariables.colorInfo) {\r\n          var color = this.getColor(geojson, visualVariables.colorInfo);\r\n          if (color) {\r\n            this._styles.fillColor = this.colorValue(color);\r\n            this._styles.fillOpacity = this.alphaValue(color);\r\n          }\r\n        }\r\n      }\r\n\r\n      if (this._symbolJson.type === 'esriPMS') {\r\n        var layerOptions = L.extend({}, { icon: this._getIcon(size) }, options);\r\n        return L.marker(latlng, layerOptions);\r\n      }\r\n      size = this.pixelValue(size);\r\n\r\n      switch (this._symbolJson.style) {\r\n        case 'esriSMSSquare':\r\n          return squareMarker(latlng, size, L.extend({}, this._styles, options));\r\n        case 'esriSMSDiamond':\r\n          return diamondMarker(latlng, size, L.extend({}, this._styles, options));\r\n        case 'esriSMSCross':\r\n          return crossMarker(latlng, size, L.extend({}, this._styles, options));\r\n        case 'esriSMSX':\r\n          return xMarker(latlng, size, L.extend({}, this._styles, options));\r\n      }\r\n      this._styles.radius = size / 2.0;\r\n      return L.circleMarker(latlng, L.extend({}, this._styles, options));\r\n    }\r\n  });\r\n\r\n  function pointSymbol (symbolJson, options) {\r\n    return new PointSymbol(symbolJson, options);\r\n  }\n\n  var LineSymbol = Symbol.extend({\r\n    statics: {\r\n      // Not implemented 'esriSLSNull'\r\n      LINETYPES: ['esriSLSDash', 'esriSLSDot', 'esriSLSDashDotDot', 'esriSLSDashDot', 'esriSLSSolid']\r\n    },\r\n    initialize: function (symbolJson, options) {\r\n      Symbol.prototype.initialize.call(this, symbolJson, options);\r\n      this._fillStyles();\r\n    },\r\n\r\n    _fillStyles: function () {\r\n      // set the defaults that show up on arcgis online\r\n      this._styles.lineCap = 'butt';\r\n      this._styles.lineJoin = 'miter';\r\n      this._styles.fill = false;\r\n      this._styles.weight = 0;\r\n\r\n      if (!this._symbolJson) {\r\n        return this._styles;\r\n      }\r\n\r\n      if (this._symbolJson.color) {\r\n        this._styles.color = this.colorValue(this._symbolJson.color);\r\n        this._styles.opacity = this.alphaValue(this._symbolJson.color);\r\n      }\r\n\r\n      if (!isNaN(this._symbolJson.width)) {\r\n        this._styles.weight = this.pixelValue(this._symbolJson.width);\r\n\r\n        var dashValues = [];\r\n\r\n        switch (this._symbolJson.style) {\r\n          case 'esriSLSDash':\r\n            dashValues = [4, 3];\r\n            break;\r\n          case 'esriSLSDot':\r\n            dashValues = [1, 3];\r\n            break;\r\n          case 'esriSLSDashDot':\r\n            dashValues = [8, 3, 1, 3];\r\n            break;\r\n          case 'esriSLSDashDotDot':\r\n            dashValues = [8, 3, 1, 3, 1, 3];\r\n            break;\r\n        }\r\n\r\n        // use the dash values and the line weight to set dash array\r\n        if (dashValues.length > 0) {\r\n          for (var i = 0; i < dashValues.length; i++) {\r\n            dashValues[i] *= this._styles.weight;\r\n          }\r\n\r\n          this._styles.dashArray = dashValues.join(',');\r\n        }\r\n      }\r\n    },\r\n\r\n    style: function (feature, visualVariables) {\r\n      if (!this._isDefault && visualVariables) {\r\n        if (visualVariables.sizeInfo) {\r\n          var calculatedSize = this.pixelValue(this.getSize(feature, visualVariables.sizeInfo));\r\n          if (calculatedSize) {\r\n            this._styles.weight = calculatedSize;\r\n          }\r\n        }\r\n        if (visualVariables.colorInfo) {\r\n          var color = this.getColor(feature, visualVariables.colorInfo);\r\n          if (color) {\r\n            this._styles.color = this.colorValue(color);\r\n            this._styles.opacity = this.alphaValue(color);\r\n          }\r\n        }\r\n      }\r\n      return this._styles;\r\n    }\r\n  });\r\n\r\n  function lineSymbol (symbolJson, options) {\r\n    return new LineSymbol(symbolJson, options);\r\n  }\n\n  var PolygonSymbol = Symbol.extend({\r\n    statics: {\r\n      // not implemented: 'esriSFSBackwardDiagonal','esriSFSCross','esriSFSDiagonalCross','esriSFSForwardDiagonal','esriSFSHorizontal','esriSFSNull','esriSFSVertical'\r\n      POLYGONTYPES: ['esriSFSSolid']\r\n    },\r\n    initialize: function (symbolJson, options) {\r\n      Symbol.prototype.initialize.call(this, symbolJson, options);\r\n      if (symbolJson) {\r\n        if (symbolJson.outline && symbolJson.outline.style === 'esriSLSNull') {\r\n          this._lineStyles = { weight: 0 };\r\n        } else {\r\n          this._lineStyles = lineSymbol(symbolJson.outline, options).style();\r\n        }\r\n        this._fillStyles();\r\n      }\r\n    },\r\n\r\n    _fillStyles: function () {\r\n      if (this._lineStyles) {\r\n        if (this._lineStyles.weight === 0) {\r\n          // when weight is 0, setting the stroke to false can still look bad\r\n          // (gaps between the polygons)\r\n          this._styles.stroke = false;\r\n        } else {\r\n          // copy the line symbol styles into this symbol's styles\r\n          for (var styleAttr in this._lineStyles) {\r\n            this._styles[styleAttr] = this._lineStyles[styleAttr];\r\n          }\r\n        }\r\n      }\r\n\r\n      // set the fill for the polygon\r\n      if (this._symbolJson) {\r\n        if (this._symbolJson.color &&\r\n            // don't fill polygon if type is not supported\r\n            PolygonSymbol.POLYGONTYPES.indexOf(this._symbolJson.style >= 0)) {\r\n          this._styles.fill = true;\r\n          this._styles.fillColor = this.colorValue(this._symbolJson.color);\r\n          this._styles.fillOpacity = this.alphaValue(this._symbolJson.color);\r\n        } else {\r\n          this._styles.fill = false;\r\n          this._styles.fillOpacity = 0;\r\n        }\r\n      }\r\n    },\r\n\r\n    style: function (feature, visualVariables) {\r\n      if (!this._isDefault && visualVariables && visualVariables.colorInfo) {\r\n        var color = this.getColor(feature, visualVariables.colorInfo);\r\n        if (color) {\r\n          this._styles.fillColor = this.colorValue(color);\r\n          this._styles.fillOpacity = this.alphaValue(color);\r\n        }\r\n      }\r\n      return this._styles;\r\n    }\r\n  });\r\n\r\n  function polygonSymbol (symbolJson, options) {\r\n    return new PolygonSymbol(symbolJson, options);\r\n  }\n\n  var Renderer = L.Class.extend({\r\n    options: {\r\n      proportionalPolygon: false,\r\n      clickable: true\r\n    },\r\n\r\n    initialize: function (rendererJson, options) {\r\n      this._rendererJson = rendererJson;\r\n      this._pointSymbols = false;\r\n      this._symbols = [];\r\n      this._visualVariables = this._parseVisualVariables(rendererJson.visualVariables);\r\n      L.Util.setOptions(this, options);\r\n    },\r\n\r\n    _parseVisualVariables: function (visualVariables) {\r\n      var visVars = {};\r\n      if (visualVariables) {\r\n        for (var i = 0; i < visualVariables.length; i++) {\r\n          visVars[visualVariables[i].type] = visualVariables[i];\r\n        }\r\n      }\r\n      return visVars;\r\n    },\r\n\r\n    _createDefaultSymbol: function () {\r\n      if (this._rendererJson.defaultSymbol) {\r\n        this._defaultSymbol = this._newSymbol(this._rendererJson.defaultSymbol);\r\n        this._defaultSymbol._isDefault = true;\r\n      }\r\n    },\r\n\r\n    _newSymbol: function (symbolJson) {\r\n      if (symbolJson.type === 'esriSMS' || symbolJson.type === 'esriPMS') {\r\n        this._pointSymbols = true;\r\n        return pointSymbol(symbolJson, this.options);\r\n      }\r\n      if (symbolJson.type === 'esriSLS') {\r\n        return lineSymbol(symbolJson, this.options);\r\n      }\r\n      if (symbolJson.type === 'esriSFS') {\r\n        return polygonSymbol(symbolJson, this.options);\r\n      }\r\n    },\r\n\r\n    _getSymbol: function () {\r\n      // override\r\n    },\r\n\r\n    attachStylesToLayer: function (layer) {\r\n      if (this._pointSymbols) {\r\n        layer.options.pointToLayer = L.Util.bind(this.pointToLayer, this);\r\n      } else {\r\n        layer.options.style = L.Util.bind(this.style, this);\r\n        layer._originalStyle = layer.options.style;\r\n      }\r\n    },\r\n\r\n    pointToLayer: function (geojson, latlng) {\r\n      var sym = this._getSymbol(geojson);\r\n      if (sym && sym.pointToLayer) {\r\n        // right now custom panes are the only option pushed through\r\n        return sym.pointToLayer(geojson, latlng, this._visualVariables, this.options);\r\n      }\r\n      // invisible symbology\r\n      return L.circleMarker(latlng, { radius: 0, opacity: 0 });\r\n    },\r\n\r\n    style: function (feature) {\r\n      var userStyles;\r\n      if (this.options.userDefinedStyle) {\r\n        userStyles = this.options.userDefinedStyle(feature);\r\n      }\r\n      // find the symbol to represent this feature\r\n      var sym = this._getSymbol(feature);\r\n      if (sym) {\r\n        return this.mergeStyles(sym.style(feature, this._visualVariables), userStyles);\r\n      } else {\r\n        // invisible symbology\r\n        return this.mergeStyles({ opacity: 0, fillOpacity: 0 }, userStyles);\r\n      }\r\n    },\r\n\r\n    mergeStyles: function (styles, userStyles) {\r\n      var mergedStyles = {};\r\n      var attr;\r\n      // copy renderer style attributes\r\n      for (attr in styles) {\r\n        if (Object.prototype.hasOwnProperty.call(styles, attr)) {\r\n          mergedStyles[attr] = styles[attr];\r\n        }\r\n      }\r\n      // override with user defined style attributes\r\n      if (userStyles) {\r\n        for (attr in userStyles) {\r\n          if (Object.prototype.hasOwnProperty.call(userStyles, attr)) {\r\n            mergedStyles[attr] = userStyles[attr];\r\n          }\r\n        }\r\n      }\r\n      return mergedStyles;\r\n    }\r\n  });\n\n  var ClassBreaksRenderer = Renderer.extend({\r\n    initialize: function (rendererJson, options) {\r\n      Renderer.prototype.initialize.call(this, rendererJson, options);\r\n      this._field = this._rendererJson.field;\r\n      if (this._rendererJson.normalizationType && this._rendererJson.normalizationType === 'esriNormalizeByField') {\r\n        this._normalizationField = this._rendererJson.normalizationField;\r\n      }\r\n      this._createSymbols();\r\n    },\r\n\r\n    _createSymbols: function () {\r\n      var symbol;\r\n      var classbreaks = this._rendererJson.classBreakInfos;\r\n\r\n      this._symbols = [];\r\n\r\n      // create a symbol for each class break\r\n      for (var i = classbreaks.length - 1; i >= 0; i--) {\r\n        if (this.options.proportionalPolygon && this._rendererJson.backgroundFillSymbol) {\r\n          symbol = this._newSymbol(this._rendererJson.backgroundFillSymbol);\r\n        } else {\r\n          symbol = this._newSymbol(classbreaks[i].symbol);\r\n        }\r\n        symbol.val = classbreaks[i].classMaxValue;\r\n        this._symbols.push(symbol);\r\n      }\r\n      // sort the symbols in ascending value\r\n      this._symbols.sort(function (a, b) {\r\n        return a.val > b.val ? 1 : -1;\r\n      });\r\n      this._createDefaultSymbol();\r\n      this._maxValue = this._symbols[this._symbols.length - 1].val;\r\n    },\r\n\r\n    _getSymbol: function (feature) {\r\n      var val = feature.properties[this._field];\r\n      if (this._normalizationField) {\r\n        var normValue = feature.properties[this._normalizationField];\r\n        if (!isNaN(normValue) && normValue !== 0) {\r\n          val = val / normValue;\r\n        } else {\r\n          return this._defaultSymbol;\r\n        }\r\n      }\r\n\r\n      if (val > this._maxValue) {\r\n        return this._defaultSymbol;\r\n      }\r\n      var symbol = this._symbols[0];\r\n      for (var i = this._symbols.length - 1; i >= 0; i--) {\r\n        if (val > this._symbols[i].val) {\r\n          break;\r\n        }\r\n        symbol = this._symbols[i];\r\n      }\r\n      return symbol;\r\n    }\r\n  });\r\n\r\n  function classBreaksRenderer (rendererJson, options) {\r\n    return new ClassBreaksRenderer(rendererJson, options);\r\n  }\n\n  var UniqueValueRenderer = Renderer.extend({\r\n    initialize: function (rendererJson, options) {\r\n      Renderer.prototype.initialize.call(this, rendererJson, options);\r\n      this._field = this._rendererJson.field1;\r\n      this._createSymbols();\r\n    },\r\n\r\n    _createSymbols: function () {\r\n      var symbol;\r\n      var uniques = this._rendererJson.uniqueValueInfos;\r\n\r\n      // create a symbol for each unique value\r\n      for (var i = uniques.length - 1; i >= 0; i--) {\r\n        symbol = this._newSymbol(uniques[i].symbol);\r\n        symbol.val = uniques[i].value;\r\n        this._symbols.push(symbol);\r\n      }\r\n      this._createDefaultSymbol();\r\n    },\r\n\r\n    _getSymbol: function (feature) {\r\n      var val = feature.properties[this._field];\r\n      // accumulate values if there is more than one field defined\r\n      if (this._rendererJson.fieldDelimiter && this._rendererJson.field2) {\r\n        var val2 = feature.properties[this._rendererJson.field2];\r\n        if (val2) {\r\n          val += this._rendererJson.fieldDelimiter + val2;\r\n          var val3 = feature.properties[this._rendererJson.field3];\r\n          if (val3) {\r\n            val += this._rendererJson.fieldDelimiter + val3;\r\n          }\r\n        }\r\n      }\r\n\r\n      var symbol = this._defaultSymbol;\r\n      for (var i = this._symbols.length - 1; i >= 0; i--) {\r\n        // using the === operator does not work if the field\r\n        // of the unique renderer is not a string\r\n        /*eslint-disable */\r\n        if (this._symbols[i].val == val) {\r\n          symbol = this._symbols[i];\r\n        }\r\n        /* eslint-enable */\r\n      }\r\n      return symbol;\r\n    }\r\n  });\r\n\r\n  function uniqueValueRenderer (rendererJson, options) {\r\n    return new UniqueValueRenderer(rendererJson, options);\r\n  }\n\n  var SimpleRenderer = Renderer.extend({\r\n    initialize: function (rendererJson, options) {\r\n      Renderer.prototype.initialize.call(this, rendererJson, options);\r\n      this._createSymbol();\r\n    },\r\n\r\n    _createSymbol: function () {\r\n      if (this._rendererJson.symbol) {\r\n        this._symbols.push(this._newSymbol(this._rendererJson.symbol));\r\n      }\r\n    },\r\n\r\n    _getSymbol: function () {\r\n      return this._symbols[0];\r\n    }\r\n  });\r\n\r\n  function simpleRenderer (rendererJson, options) {\r\n    return new SimpleRenderer(rendererJson, options);\r\n  }\n\n  function wireUpRenderers () {\r\n    if (this.options.ignoreRenderer) {\r\n      return;\r\n    }\r\n    var oldOnAdd = L.Util.bind(this.onAdd, this);\r\n    var oldUnbindPopup = L.Util.bind(this.unbindPopup, this);\r\n    var oldOnRemove = L.Util.bind(this.onRemove, this);\r\n\r\n    L.Util.bind(this.createNewLayer, this);\r\n\r\n    this.onAdd = function (map) {\r\n      this.metadata(function (error, response) {\r\n        if (error) {\r\n          console.warn('failed to load metadata from the service.');\r\n          return;\r\n        } if (response && response.drawingInfo) {\r\n          if (this.options.drawingInfo) {\r\n            // allow L.esri.webmap (and others) to override service symbology with info provided in layer constructor\r\n            response.drawingInfo = this.options.drawingInfo;\r\n          }\r\n\r\n          // the default pane for lines and polygons is 'overlayPane', for points it is 'markerPane'\r\n          if (this.options.pane === 'overlayPane' && response.geometryType === 'esriGeometryPoint') {\r\n            this.options.pane = 'markerPane';\r\n          }\r\n\r\n          this._setRenderers(response);\r\n          oldOnAdd(map);\r\n          this._addPointLayer(map);\r\n        }\r\n      }, this);\r\n    };\r\n\r\n    this.onRemove = function (map) {\r\n      oldOnRemove(map);\r\n      if (this._pointLayer) {\r\n        var pointLayers = this._pointLayer.getLayers();\r\n        for (var i in pointLayers) {\r\n          map.removeLayer(pointLayers[i]);\r\n        }\r\n      }\r\n    };\r\n\r\n    this.unbindPopup = function () {\r\n      oldUnbindPopup();\r\n      if (this._pointLayer) {\r\n        var pointLayers = this._pointLayer.getLayers();\r\n        for (var i in pointLayers) {\r\n          pointLayers[i].unbindPopup();\r\n        }\r\n      }\r\n    };\r\n\r\n    this._addPointLayer = function (map) {\r\n      if (this._pointLayer) {\r\n        this._pointLayer.addTo(map);\r\n        this._pointLayer.bringToFront();\r\n      }\r\n    };\r\n\r\n    this._createPointLayer = function () {\r\n      if (!this._pointLayer) {\r\n        this._pointLayer = L.geoJson();\r\n        // store the feature ids that have already been added to the map\r\n        this._pointLayerIds = {};\r\n\r\n        if (this._popup) {\r\n          var popupFunction = function (feature, layer) {\r\n            layer.bindPopup(this._popup(feature, layer), this._popupOptions);\r\n          };\r\n          this._pointLayer.options.onEachFeature = L.Util.bind(popupFunction, this);\r\n        }\r\n      }\r\n    };\r\n\r\n    this.createNewLayer = function (geojson) {\r\n      var fLayer = L.GeoJSON.geometryToLayer(geojson, this.options);\r\n\r\n      // add a point layer when the polygon is represented as proportional marker symbols\r\n      if (this._hasProportionalSymbols) {\r\n        var centroid = this.getPolygonCentroid(geojson.geometry.coordinates);\r\n        if (!(isNaN(centroid[0]) || isNaN(centroid[0]))) {\r\n          this._createPointLayer();\r\n\r\n          var featureId = geojson.id.toString();\r\n          // only add the feature if it does not already exist on the map\r\n          if (!this._pointLayerIds[featureId]) {\r\n            var pointjson = this.getPointJson(geojson, centroid);\r\n\r\n            this._pointLayer.addData(pointjson);\r\n            this._pointLayerIds[featureId] = true;\r\n          }\r\n\r\n          this._pointLayer.bringToFront();\r\n        }\r\n      }\r\n      return fLayer;\r\n    };\r\n\r\n    this.getPolygonCentroid = function (coordinates) {\r\n      var pts = coordinates[0][0];\r\n      if (pts.length === 2) {\r\n        pts = coordinates[0];\r\n      }\r\n\r\n      var twicearea = 0;\r\n      var x = 0;\r\n      var y = 0;\r\n      var nPts = pts.length;\r\n      var p1;\r\n      var p2;\r\n      var f;\r\n\r\n      for (var i = 0, j = nPts - 1; i < nPts; j = i++) {\r\n        p1 = pts[i]; p2 = pts[j];\r\n        twicearea += p1[0] * p2[1];\r\n        twicearea -= p1[1] * p2[0];\r\n        f = (p1[0] * p2[1]) - (p2[0] * p1[1]);\r\n        x += (p1[0] + p2[0]) * f;\r\n        y += (p1[1] + p2[1]) * f;\r\n      }\r\n      f = twicearea * 3;\r\n      return [x / f, y / f];\r\n    };\r\n\r\n    this.getPointJson = function (geojson, centroid) {\r\n      return {\r\n        type: 'Feature',\r\n        properties: geojson.properties,\r\n        id: geojson.id,\r\n        geometry: {\r\n          type: 'Point',\r\n          coordinates: [centroid[0], centroid[1]]\r\n        }\r\n      };\r\n    };\r\n\r\n    this._checkForProportionalSymbols = function (geometryType, renderer) {\r\n      this._hasProportionalSymbols = false;\r\n      if (geometryType === 'esriGeometryPolygon') {\r\n        if (renderer.backgroundFillSymbol) {\r\n          this._hasProportionalSymbols = true;\r\n        }\r\n        // check to see if the first symbol in the classbreaks is a marker symbol\r\n        if (renderer.classBreakInfos && renderer.classBreakInfos.length) {\r\n          var sym = renderer.classBreakInfos[0].symbol;\r\n          if (sym && (sym.type === 'esriSMS' || sym.type === 'esriPMS')) {\r\n            this._hasProportionalSymbols = true;\r\n          }\r\n        }\r\n      }\r\n    };\r\n\r\n    this._setRenderers = function (serviceInfo) {\r\n      var rend;\r\n      var rendererInfo = serviceInfo.drawingInfo.renderer;\r\n\r\n      var options = {\r\n        url: this.options.url\r\n      };\r\n\r\n      if (this.options.token) {\r\n        options.token = this.options.token;\r\n      }\r\n\r\n      if (this.options.pane) {\r\n        options.pane = this.options.pane;\r\n      }\r\n\r\n      if (serviceInfo.drawingInfo.transparency) {\r\n        options.layerTransparency = serviceInfo.drawingInfo.transparency;\r\n      }\r\n\r\n      if (this.options.style) {\r\n        options.userDefinedStyle = this.options.style;\r\n      }\r\n\r\n      switch (rendererInfo.type) {\r\n        case 'classBreaks':\r\n          this._checkForProportionalSymbols(serviceInfo.geometryType, rendererInfo);\r\n          if (this._hasProportionalSymbols) {\r\n            this._createPointLayer();\r\n            var pRend = classBreaksRenderer(rendererInfo, options);\r\n            pRend.attachStylesToLayer(this._pointLayer);\r\n            options.proportionalPolygon = true;\r\n          }\r\n          rend = classBreaksRenderer(rendererInfo, options);\r\n          break;\r\n        case 'uniqueValue':\r\n          rend = uniqueValueRenderer(rendererInfo, options);\r\n          break;\r\n        default:\r\n          rend = simpleRenderer(rendererInfo, options);\r\n      }\r\n      rend.attachStylesToLayer(this);\r\n    };\r\n  }\r\n\r\n  EsriLeaflet__namespace.FeatureLayer.addInitHook(wireUpRenderers);\r\n\r\n  if (typeof EsriLeafletCluster__default[\"default\"] !== 'undefined' && EsriLeafletCluster.FeatureLayer) {\r\n    EsriLeafletCluster.FeatureLayer.addInitHook(wireUpRenderers);\r\n  }\n\n  var name = \"esri-leaflet-renderers\";\n  var description = \"esri-leaflet plugin for rendering\";\n  var version$1 = \"3.0.1\";\n  var author = \"Rachel Nehmer\";\n  var bugs = {\n  \turl: \"https://github.com/esri/esri-leaflet-renderers/issues\"\n  };\n  var contributors = [\n  \t\"Rachel Nehmer\",\n  \t\"John Gravois (https://johngravois.com)\",\n  \t\"Gavin Rehkemper (https://gavinr.com)\"\n  ];\n  var peerDependencies = {\n  \t\"esri-leaflet\": \"3.x\",\n  \tleaflet: \"1.x\",\n  \t\"leaflet-shape-markers\": \"1.x\"\n  };\n  var optionalDependencies = {\n  \t\"esri-leaflet-cluster\": \"^3.0.0\"\n  };\n  var devDependencies = {\n  \t\"@rollup/plugin-json\": \"^4.1.0\",\n  \t\"@rollup/plugin-node-resolve\": \"^13.1.3\",\n  \t\"@rollup/plugin-terser\": \"^0.3.0\",\n  \tchai: \"4.3.6\",\n  \t\"chokidar-cli\": \"^3.0.0\",\n  \t\"esri-leaflet\": \"3.x\",\n  \t\"gh-release\": \"^7.0.2\",\n  \t\"http-server\": \"^14.1.1\",\n  \tkarma: \"^6.3.16\",\n  \t\"karma-chai-sinon\": \"^0.1.5\",\n  \t\"karma-chrome-launcher\": \"^3.1.0\",\n  \t\"karma-coverage\": \"^2.2.0\",\n  \t\"karma-mocha\": \"^2.0.1\",\n  \t\"karma-mocha-reporter\": \"^2.2.5\",\n  \t\"karma-sourcemap-loader\": \"^0.3.8\",\n  \tleaflet: \"1.x\",\n  \t\"leaflet-shape-markers\": \"^1.0.6\",\n  \tmkdirp: \"^1.0.4\",\n  \tmocha: \"^10.2.0\",\n  \t\"npm-run-all\": \"^4.1.5\",\n  \trollup: \"^2.79.1\",\n  \tsemistandard: \"^14.2.3\",\n  \tsinon: \"^15.0.1\",\n  \t\"sinon-chai\": \"3.7.0\",\n  \tsnazzy: \"^9.0.0\"\n  };\n  var files = [\n  \t\"src/**/*.js\",\n  \t\"dist/*.js\",\n  \t\"dist/*.js.map\",\n  \t\"dist/*.json\"\n  ];\n  var homepage = \"http://developers.arcgis.com/esri-leaflet\";\n  var jspm = {\n  \tregistry: \"npm\",\n  \tformat: \"es6\",\n  \tmain: \"src/EsriLeafletRenderers.js\"\n  };\n  var keywords = [\n  \t\"arcgis\",\n  \t\"esri\",\n  \t\"esri leaflet\",\n  \t\"gis\",\n  \t\"leaflet plugin\",\n  \t\"mapping\",\n  \t\"renderers\",\n  \t\"symbology\"\n  ];\n  var license = \"Apache-2.0\";\n  var main = \"dist/esri-leaflet-renderers-debug.js\";\n  var module = \"src/EsriLeafletRenderers.js\";\n  var browser = \"dist/esri-leaflet-renderers-debug.js\";\n  var readmeFilename = \"README.md\";\n  var repository = {\n  \ttype: \"git\",\n  \turl: \"git@github.com:Esri/esri-leaflet-renderers.git\"\n  };\n  var scripts = {\n  \tprebuild: \"mkdirp dist\",\n  \tbuild: \"rollup -c profiles/debug.js & rollup -c profiles/production.js\",\n  \tlint: \"semistandard src/**/*.js | snazzy\",\n  \tfix: \"semistandard --fix\",\n  \tpretest: \"npm run build\",\n  \trelease: \"./scripts/release.sh\",\n  \t\"start-watch\": \"chokidar src -c \\\"npm run build\\\"\",\n  \tstart: \"run-p start-watch serve\",\n  \tserve: \"http-server -p 5000 -c-1 -o\",\n  \ttest: \"npm run lint && karma start\",\n  \t\"test:ci\": \"npm run lint && karma start --browsers Chrome_travis_ci\"\n  };\n  var packageInfo = {\n  \tname: name,\n  \tdescription: description,\n  \tversion: version$1,\n  \tauthor: author,\n  \tbugs: bugs,\n  \tcontributors: contributors,\n  \tpeerDependencies: peerDependencies,\n  \toptionalDependencies: optionalDependencies,\n  \tdevDependencies: devDependencies,\n  \tfiles: files,\n  \thomepage: homepage,\n  \t\"jsnext:main\": \"src/EsriLeafletRenderers.js\",\n  \tjspm: jspm,\n  \tkeywords: keywords,\n  \tlicense: license,\n  \tmain: main,\n  \tmodule: module,\n  \tbrowser: browser,\n  \treadmeFilename: readmeFilename,\n  \trepository: repository,\n  \tscripts: scripts\n  };\n\n  var version = packageInfo.version;\n\n  exports.ClassBreaksRenderer = ClassBreaksRenderer;\n  exports.LineSymbol = LineSymbol;\n  exports.PointSymbol = PointSymbol;\n  exports.PolygonSymbol = PolygonSymbol;\n  exports.Renderer = Renderer;\n  exports.SimpleRenderer = SimpleRenderer;\n  exports.Symbol = Symbol;\n  exports.UniqueValueRenderer = UniqueValueRenderer;\n  exports.VERSION = version;\n  exports.classBreaksRenderer = classBreaksRenderer;\n  exports.lineSymbol = lineSymbol;\n  exports.pointSymbol = pointSymbol;\n  exports.polygonSymbol = polygonSymbol;\n  exports.simpleRenderer = simpleRenderer;\n  exports.uniqueValueRenderer = uniqueValueRenderer;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n//# sourceMappingURL=esri-leaflet-renderers-debug.js.map\n\n\n//# sourceURL=webpack://sadaf/./node_modules/esri-leaflet-renderers/dist/esri-leaflet-renderers-debug.js?");

/***/ }),

/***/ "./node_modules/esri-leaflet-cluster/package.json":
/*!********************************************************!*\
  !*** ./node_modules/esri-leaflet-cluster/package.json ***!
  \********************************************************/
/***/ ((module) => {

"use strict";
eval("module.exports = /*#__PURE__*/JSON.parse('{\"_from\":\"esri-leaflet-cluster@^3.0.0\",\"_id\":\"esri-leaflet-cluster@3.0.1\",\"_inBundle\":false,\"_integrity\":\"sha512-rqI4inhOzqZqGj0nfYNdfnDI51mGEpdefw4M4WoA0ig1FVh0V5W9ecRuHXbaBim+R7SSKMwY30S2wKipcYoF2w==\",\"_location\":\"/esri-leaflet-cluster\",\"_phantomChildren\":{},\"_requested\":{\"type\":\"range\",\"registry\":true,\"raw\":\"esri-leaflet-cluster@^3.0.0\",\"name\":\"esri-leaflet-cluster\",\"escapedName\":\"esri-leaflet-cluster\",\"rawSpec\":\"^3.0.0\",\"saveSpec\":null,\"fetchSpec\":\"^3.0.0\"},\"_requiredBy\":[\"/esri-leaflet-renderers\"],\"_resolved\":\"https://registry.npmjs.org/esri-leaflet-cluster/-/esri-leaflet-cluster-3.0.1.tgz\",\"_shasum\":\"ba9fcea19f5cd74a2eeff68872c23f9fc8cd2627\",\"_spec\":\"esri-leaflet-cluster@^3.0.0\",\"_where\":\"D:\\\\\\\\SadafSource\\\\\\\\branches\\\\\\\\dev\\\\\\\\Web\\\\\\\\node_modules\\\\\\\\esri-leaflet-renderers\",\"author\":{\"name\":\"Patrick Arlt\",\"email\":\"parlt@esri.com\",\"url\":\"http://patrickarlt.com\"},\"bugs\":{\"url\":\"https://github.com/Esri/esri-leaflet-cluster/issues\"},\"bundleDependencies\":false,\"contributors\":[{\"name\":\"Patrick Arlt\",\"email\":\"parlt@esri.com\",\"url\":\"http://patrickarlt.com\"},{\"name\":\"John Gravois\",\"url\":\"http://johngravois.com\"}],\"deprecated\":false,\"description\":\"Esri Leaflet plugin for visualizing Feature Layers as clusters with L.markercluster.\",\"devDependencies\":{\"@rollup/plugin-json\":\"^6.0.0\",\"@rollup/plugin-node-resolve\":\"^15.0.1\",\"@rollup/plugin-terser\":\"^0.4.0\",\"chai\":\"4.3.7\",\"chokidar-cli\":\"^3.0.0\",\"gh-release\":\"^7.0.2\",\"http-server\":\"^14.1.1\",\"karma\":\"^6.4.1\",\"karma-chrome-launcher\":\"^3.1.1\",\"karma-coverage\":\"^2.2.0\",\"karma-edgium-launcher\":\"github:matracey/karma-edgium-launcher\",\"karma-firefox-launcher\":\"^2.1.2\",\"karma-mocha\":\"^2.0.1\",\"karma-mocha-reporter\":\"^2.2.5\",\"karma-safari-launcher\":\"~1.0.0\",\"karma-sinon-chai\":\"^2.0.2\",\"karma-sourcemap-loader\":\"^0.3.8\",\"mkdirp\":\"^1.0.4\",\"mocha\":\"^10.2.0\",\"node-sass\":\"^7.0.1\",\"npm-run-all\":\"^4.1.5\",\"rollup\":\"^2.79.1\",\"semistandard\":\"^11.0.0\",\"sinon\":\"^15.0.1\",\"sinon-chai\":\"3.7.0\",\"snazzy\":\"^9.0.0\"},\"homepage\":\"https://github.com/Esri/esri-leaflet-cluster\",\"jsnext:main\":\"src/ClusterFeatureLayer.js\",\"jspm\":{\"registry\":\"npm\",\"format\":\"es6\",\"main\":\"src/ClusterFeatureLayer.js\"},\"keywords\":[\"arcgis\",\"esri\",\"esri leaflet\",\"gis\",\"leaflet plugin\",\"mapping\"],\"license\":\"Apache-2.0\",\"main\":\"dist/esri-leaflet-cluster-debug.js\",\"module\":\"src/ClusterFeatureLayer.js\",\"name\":\"esri-leaflet-cluster\",\"peerDependencies\":{\"esri-leaflet\":\"*\",\"leaflet\":\"*\",\"leaflet.markercluster\":\"^1.0.0\"},\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/Esri/esri-leaflet-cluster.git\"},\"scripts\":{\"build\":\"rollup -c profiles/debug.js & rollup -c profiles/production.js\",\"lint\":\"semistandard | snazzy\",\"prebuild\":\"mkdirp dist\",\"pretest\":\"npm run build\",\"release\":\"./scripts/release.sh\",\"serve\":\"http-server -p 5678 -c-1 -o\",\"start\":\"run-p start-watch serve\",\"start-watch\":\"chokidar src -c \\\\\"npm run build\\\\\"\",\"test\":\"npm run lint && karma start\"},\"semistandard\":{\"globals\":[\"expect\",\"L\",\"sinon\"]},\"version\":\"3.0.1\"}');\n\n//# sourceURL=webpack://sadaf/./node_modules/esri-leaflet-cluster/package.json?");

/***/ })

}]);